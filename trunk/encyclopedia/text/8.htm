<html><head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="..\encyclopedia.css"><script type="text/javascript" src="..\encyclopedia.js"></script></head><body onload="page();"><xmp>

Cначала определим терминологию: 
Абсолютный адрес: это адрес, по которому происходит обращение к переменной по законам PlayStation. Адресное пространство ОЗУ игры занимает 2097152 байт (ровно 2 мегабайта). Начинается с адреса 80000000h (2147483648) и заканчивается 801FFFFFh (2149580799). Именно в него ДОЛЖНЫ указывать ВСЕ указатели! 
Истинный адрес: это физический адрес ОЗУ компьютера, где эмулятор размещает данные памяти игры. Он, естественно, тоже занимает объём 2 Мб, но первый адрес отличается он абсолютного. Наверное, зависит от эмулятора. В Epsxe 1.7.2 это от 0094C020h (9748512) до 00B4C01Fh (11845663). По этим адресам можно найти указатели и строки в ArtMoney. Это адрес истинный для нас, но ложный для игры, и направлять что-либо на него бесполезно. 
Прямой адрес: это адрес данных дампа памяти. Дамп я предлагаю снимать через свой же MemGet. Пространство также 2 Мб, но начинается с адреса 00000000h (0) и кончается 001FFFFFh (2097151). Так проще всего понять, где на самом деле расположены данные. 
Относительный адрес: это адрес данных внутри субфайла или суб-субфайла. Или же относительно всего WAD. Или относительно сектора диска – смотря что имеется в виду. Далее по тексту под относительным адресом я буду понимать только адрес данных от начала четвёртого суб-субфайла главного субфайла любого уровня. 

Преобразование между адресами. X – новый адрес, Y – известный адрес: 

АА-->ПА : X=Y-2147483648 
ПА-->АА : X=Y+2147483648 
ПА-->ИА : X=Y+9748512 
ИА-->ПА : X=Y-9748512 
АА-->ИА : X=Y-2137735136 
ИА-->АА : X=Y+2137735136 
Для относительного адреса нужно знать константу, которую игра суммирует с ним. Её можно найти, вычитая из АА строки ОА этой же строки. Но нам такое совершенно не понадобиться. 

http://Klimaleksus.narod2.ru/Files/StrPnt.rar
http://Klimaleksus.narod2.ru/Files/Mem.rar

Итак, это 7в1. (MemGet тоже понадобится.) Программки: STR,PNT,NUL,COP,SET,SUB,HEX. 
STR – ищет строку. 
PNT – ищет указатель. 
NUL – ищет пустое пространство. 
COP – копирует данные (строки) + добавляет свои. 
SET – изменяет указатели. 
SUB – производит сложение и вычитание по правилам «1-2=4294967295» 
HEX – конвертирует между десятичной и шестнадцатеричной системами. 

Все файлы выбираются соответствующими кнопками «...», подтверждать не надо. 
Поиски STR,PNT,NUL – выполняются кнопкой Search, а результат выводится в Offset found. 
Строку надо писать в текстовое поле, а указатель – в Value (всё записывается только в десятичной системе счисления) 
Count – количество найденных элементов. Если «1» – это хорошо. Если «0» – значит вы ничего не нашли. Если больше 1 – слишком много повторов. Уточните строку или просмотримте файл через WinHex, чтобы понять, почему так происходит. 
Use# – порядковый номер выводимой строки или указателя, если их несколько (например, «Hunter» встречается пару-тройку раз, и чтобы обработать их все, нажимайте Search при разных Use# (от 1 до Count) и копируйте Offset found). 
Start address – начальный адрес в файле для поиска. «0» – поиск во всём файле. Можно использовать, чтобы уточнить место и сократить время, или отсеять ранние вхождения. 

STR-Difference – это специальное поле, которое автоматически суммируется с результатом. То есть, чтобы найти настоящую строку, нужно поставить туда ноль. Но если мы ищем фразу, которая начинается не с самих букв, а за четыре байта ранее, то логично ввести туда «-4», и прога выдаст адрес искомой строки, из которого уже буде вычтено 4. 
PNT-Difference – это тоже «сумматор», но входных данных. То есть указатель ищется на Value+Difference. Зачем? Да потому что в Difference удобно помещать константы конвертации адресных пространств, например, начало абсолютного адреса 2147483648. 

Как работает NUL: Ищет «00h» по всему файлу, выдавая первый за вычетом Padding, но чтобы их последовательность была не меньше Minimum в сумме с Padding. Проще говоря, находит первую область в Minimum нулей, перед которой есть ещё ровно Padding нулей. Мы задаём Padding=4 и Minimum больше 50 (64, 500 или сколько будет нужно – длина новой строки), кастуем на второй суб-субфайл, и нам выдаётся та самая яичная зона! 

COP – Копирует из файла From с адреса Address в файл To по адресу Desten данные. Длина копируемой области – Length. Плюс добавляет сюда строку Text и Add blank пробелов после неё. Короче, Length приравнивается STR-Difference (с противоположным знаком), которая была нужна для отлова строки. Или 0 или 4. 
Добавляемый текст – новая строка. Можно поставить Length=8, тогда скопируется оригинальное начало; в Text ввести что-то типа «OurString01», а в Add blank – ту длину новой стрики, которая планируется (например с запасом). Потом уже всё это изменить можно через знакомый Текст-О-Вытаскиватель. 
Кстати, не копируйте много через Length, лучше ставьте Add blank, потому что потом можно запутаться, где оригинал, а где изменение при следующих поисках строк. 

SET – ну тут всё просто. Вставляете адрес в Address, жмёте GET и получаете значение указателя. Изменяете его на нужное, жмёте PUT – вуаля, он записан! 

SUB – «Кулькулятор»… Вводите операнды в два поля и нажимаете «+» или «-» между ними – в третье поле выведется ответ, не затирая оригиналы. 

HEX – конвертор по мере ввода. Я сделал поддержку до FFFFFFFFFFFFFFFFh, но он на больших числах конечно неизбежно гонит. А до четырёх байт FFFFFFFFh вычисляет великолепно! 

Всё! Моих программ StrPnt и GetMem достаточно для изменения любой строки в игре. Но всегда лучше контролировать поведение в WinHex. Общий алгоритм изменения строк (обращение к результатам предыдущего пункта обозначено фигурными скобками): 

1) STR. Ищем исходную строку в 4-ом суб-субфайле. 
2) NUL. Ищем пустоту в 2-ом суб-субфайле. 
3) PNT. Ищем в 4-ом суб-субфайле указатель на адрес, полученный в {п.1}. 
4) COP. Из адреса {п.1} копируем в адрес {п.2} из 4-го в 2-ой субфайл, добавив свою новую строку. 
5) SET. Делаем GET в 4-ом суб-субфайле на адрес {п.3}, должны получить {п.1} 
~Внедряем 2-ой суб-субфайл, компилируем и прожигаем игру. Запускаем, заходим в нужный уровень и снимаем полный дамп памяти через MemGet.~ 
6) STR. Ищем оригинальную строку в дампе. 
7) STR. Ищем нашу изменённую строку в том же дампе. 
8) SUB. Вычитаем из изменённого {п.6} оригинальный {п.7}. 
9) SET. Делаем PUT на адрес {п.3} 4-го суб-субфайла и заносим {п.8}. 
~Внедряем 4-ый суб-субфайл, компилируем, прожигаем, запускаем и заходим в нужный уровень – должен быть верный результат~ 

Ремарочки: 
– Если меняем ФРАЗУ, то Difference в пунктах 1,6,7 надо ставить «-4». Если ИМЯ, то «0». 
– Если пункт 3 ничего не дал, то попробуйте изменять Difference на +- от 1 до 4 туда-сюда. Если и это не помогло (абсолютный адрес!), то пропустите этот пункт (и пятый), а вместо пунктов 8 и 9 сделайте так: 
10) PNT. Ищем указатель в дампе на {п.6}. 
11) SET. Делаем GET в дампе на адрес {п.10}, должны получить {п.6} 
12) SET. Теперь делаем PUT в дампе на тот же адрес, но занесите {п.7} 
– Если хотите увидеть указатель или строку в ArtMoney, то отнимите от адреса число «147483648», прибавьте первый истинный адрес «9748512» (можно в SUB) и переведите (можно в HEX) в шестнадцатеричную систему. После чего в ArtMoney задайте «перемещение на адрес» в «редакторе памяти».

</xmp></body></html>